package io.nayasis.common.reflection.core;

import io.nayasis.common.base.Classes;
import io.nayasis.common.base.Strings;
import io.nayasis.common.base.Validator;
import io.nayasis.common.cache.implement.LruCache;
import io.nayasis.common.exception.unchecked.UncheckedIllegalAccessException;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;


/**
 * Core reflector
 *
 * @author nayasis@gmail.com
 * @since 2017-03-24
 */
public class CoreReflector {

    private static final LruCache<Class,Set<Field>>       CACHE_FIELD       = new LruCache<>(256 );
    private static final LruCache<Class,Set<Method>>      CACHE_METHOD      = new LruCache<>(256 );
    private static final LruCache<Class,Set<Constructor>> CACHE_CONSTRUCTOR = new LruCache<>(256 );

    /**
     * set value to target instance's field.
     *
     * @param target    target instance
     * @param field     target field
     * @param value     value to modify
     */
    public static void setValue( Object target, Field field, Object value ) {
        execute( target, field, () -> {
            if( field.isSynthetic()    ) return;
            if( field.isEnumConstant() ) return;
            if( Modifier.isStatic(field.getModifiers()) ){
                field.set( null, value );
            } else {
                field.set( target, value );
            }
        });
    }

    /**
     * get value from target instance's field
     *
     * @param target    target instance
     * @param field     target field
     * @param <T>
     * @return  field's value
     */
    public static <T> T getValue( Object target, Field field ) {

        final Object[] val = new Object[ 1 ];

        execute( target, field, () -> {
            if( Modifier.isStatic(field.getModifiers()) ){
                val[0] = field.get( null );
            } else {
                val[0] = field.get( target );
            }
        });

        return val[0] == null ? null : (T) val[0];

    }

    private static void execute( Object target, Field field, Runner runner ) {

        if( target == null || field == null ) return;

        boolean inaccessible = ! field.isAccessible();

        if( inaccessible )
            field.setAccessible( true );

        try {
            runner.run();
        } catch( IllegalAccessException e ) {
            throw new UncheckedIllegalAccessException( e );
        } finally {
            if( inaccessible ) {
                field.setAccessible( false );
            }
        }

    }

    private interface Runner {
        void run() throws IllegalAccessException;
    }

    /**
     * Get fields in object
     *
     * @param object    object to extract fields
     * @return fields
     */
    public static Set<Field> getFields( Object object ) {
        if( object == null ) return new HashSet<>();
        return getFields( object.getClass() );
    }

    public static Set<Field> getFields( Class klass ) {

        if( klass == null ) return new HashSet<>();

        if( CACHE_FIELD.contains(klass) )
            return CACHE_FIELD.get( klass );

        Set<Field> fields = new HashSet<>();

        Classes.findParents( klass ).forEach( parent -> {
           fields.addAll( getFields( parent ) );
        });

        for( Field field : klass.getDeclaredFields() ) {
            if( field.isSynthetic() ) continue; // if field is generated by compiler, skip it.
            fields.add( field );
        }

        CACHE_FIELD.putIfAbsent( klass, fields );

        return fields;

    }

    public static Set<Field> getFields( Object target, String regex ) {
        if( target == null ) return new HashSet<>();
        return getFields( target.getClass(), regex );
    }

    public static Set<Field> getFields( Class klass, String regex ) {
        if( Strings.isEmpty(regex) ) return new HashSet<>();
        Set<Field> result = new HashSet<>();
        for( Field field : getFields(klass) ) {
            if( field.getName().matches(regex) ) {
                result.add( field );
            }
        }
        return result;
    }

    public static Set<Method> getMethods( Object object ) {
        if( object == null ) return new HashSet<>();
        return getMethods( object.getClass() );
    }

    public static Set<Method> getMethods( Class klass ) {

        if( klass == null ) return new HashSet<>();

        if( CACHE_METHOD.contains(klass) )
            return CACHE_METHOD.get( klass );

        Set<Method> methods = new HashSet<>();

        Classes.findParents( klass ).forEach( parent -> {
            methods.addAll( getMethods( parent ) );
        });

        for( Method method : klass.getDeclaredMethods() ) {
            if( method.isSynthetic() ) continue; // if method is generated by compiler, skip it.
            if( Modifier.isInterface(method.getModifiers()) ) continue;
            if( Modifier.isAbstract(method.getModifiers()) ) continue;
            methods.add( method );
        }

        CACHE_METHOD.putIfAbsent( klass, methods );

        return methods;

    }

    public static Set<Method> getMethods( Object target, String regex ) {
        if( target == null ) return new HashSet<>();
        return getMethods( target.getClass(), regex );
    }

    public static Set<Method> getMethods( Class klass, String regex ) {
        if( Validator.isEmpty(regex) ) return new HashSet<>();
        Set<Method> result = new LinkedHashSet<>();
        for( Method method : getMethods(klass) ) {
            if( method.getName().matches(regex) ) {
                result.add( method );
            }
        }
        return result;
    }

    public static Set<Constructor> getContructors( Object target ) {
        if( target == null ) return new HashSet<>();
        return getContructors( target.getClass() );
    }

    public static Set<Constructor> getContructors( Class klass ) {

        if( klass == null ) return new HashSet<>();

        if( CACHE_CONSTRUCTOR.contains(klass) )
            return CACHE_CONSTRUCTOR.get( klass );

        Set<Constructor> constructors = new HashSet<>();

        for( Constructor constructor : klass.getDeclaredConstructors() ) {
            // if constructor is generated by compiler, skip it.
            if( constructor.isSynthetic() ) continue;
            constructors.add( constructor );
        }

        CACHE_CONSTRUCTOR.putIfAbsent( klass, constructors );

        return constructors;

    }

}
