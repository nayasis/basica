package io.nayasis.common.basica.file;import io.nayasis.common.basica.base.Classes;import io.nayasis.common.basica.base.Strings;import io.nayasis.common.basica.exception.unchecked.BaseRuntimeException;import io.nayasis.common.basica.exception.unchecked.UncheckedClassNotFoundException;import io.nayasis.common.basica.exception.unchecked.UncheckedFileNotFoundException;import io.nayasis.common.basica.exception.unchecked.UncheckedIOException;import io.nayasis.common.basica.file.handler.FileFinder;import io.nayasis.common.basica.file.handler.ZipFileHandler;import io.nayasis.common.basica.file.worker.BufferWriter;import io.nayasis.common.basica.file.worker.LineReader;import io.nayasis.common.basica.model.NList;import lombok.experimental.UtilityClass;import org.mozilla.universalchardet.UniversalDetector;import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.URISyntaxException;import java.net.URL;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.CopyOption;import java.nio.file.FileVisitOption;import java.nio.file.FileVisitResult;import java.nio.file.InvalidPathException;import java.nio.file.LinkOption;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.SimpleFileVisitor;import java.nio.file.StandardCopyOption;import java.nio.file.attribute.BasicFileAttributes;import java.util.ArrayList;import java.util.EnumSet;import java.util.List;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * File Utility * * @author nayasis@gmail.com * */@UtilityClasspublic class Files {    private static final String UTF_8 = StandardCharsets.UTF_8.toString();    private static final String CHARSET_AUTODETECT = "";    /**     * Delete file or directory     *     * @param filePath  file path or directory path     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */	public static void delete( Path filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {		if( filePath == null || notExists( filePath ) ) return;		try {            if( isDirectory(filePath) ) {                java.nio.file.Files.walkFileTree( filePath, new SimpleFileVisitor<Path>() {                    @Override                    public FileVisitResult visitFile( Path file, BasicFileAttributes attributes ) throws IOException {                        java.nio.file.Files.delete(file);                        return FileVisitResult.CONTINUE;                    }                    @Override                    public FileVisitResult visitFileFailed( Path file, IOException e ) throws IOException {                        java.nio.file.Files.delete(file);                        return FileVisitResult.CONTINUE;                    }                    @Override                    public FileVisitResult postVisitDirectory( Path dir, IOException e ) throws IOException {                        if ( e != null) throw e;                        java.nio.file.Files.delete( dir );                        return FileVisitResult.CONTINUE;                    }                });            } else {                java.nio.file.Files.delete( filePath );            }        } catch( IOException e ) {        	throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }	}    /**     * Delete file or directory     *     * @param filePath  file path or directory path     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void delete( String filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        if( filePath == null ) return;    	delete( Paths.get(filePath) );    }    /**     * Delete file or directory     *     * @param filePath  file or directory path     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void delete( File filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        if( filePath == null ) return;        delete( filePath.toPath() );    }    /**     * Get file extension     *     * @param filePath  file name or full path     * @return file extension     */    public static String getExtension( String filePath ) {        if( filePath == null ) return "";        int index = filePath.lastIndexOf( '.' );        if( index < 0 ) return "";        String ext = filePath.substring( index + 1 );        if( ext.contains(File.pathSeparator) || ext.contains("/") ) return "";        return ext;    }    /**     * Get file extension     *     * @param file  file     * @return file extension     */    public static String getExtension( File file ) {    	return ( file == null ) ? "" : getExtension( file.getName() );    }    /**     * Get file extention     *     * @param path  path     * @return file extension     */    public static String getExtension( Path path ) {        return ( path == null ) ? "" : getExtension( path.getFileName().toString() );    }    /**     * normalize file separator to "/" and remove last "/" seperator.     *     * <pre>     *     Files.normalizeSeparator( "c:\\document/a/b\\c" );     *       -> "c:/document/a/b/c"     * </pre>     *     * @param filePath  file path     * @return file path having "/" separator only.     */    public static String normalizeSeparator( String filePath ) {        return Strings.nvl( filePath ).trim()            .replaceAll( "(?!^)\\\\+", "/" ) // skip first double slash (it used for NAS path)            .replaceFirst( "(.*)/$", "$1" )            ;    }    /**     * Search list of files or directories in sub directory.     *     *     * @param searchDir         root directory to search     * @param includeFile       include file     * @param includeDirectory  include directory     * @param scanDepth         depth to scan     * <pre>     *   -1 : infinite     *    0 : in searchDir itself     *    1 : from searchDir to 1 depth sub directory     *    2 : from searchDir to 2 depth sub directory     *    ...     * </pre>     * @param matchingPattern   path matching pattern (glob expression. if not exists, add all result)     * <pre>     * ** : ignore directory variation     * *  : filename LIKE search     *     * 1. **.xml           : all files having "xml" extension below searchDir and it's all sub directories.     * 2. *.xml            : all files having "xml" extension in searchDir     * 3. c:\home\*\*.xml  : all files having "xml" extension below 'c:\home\' and it's just 1 depth below directories.     * 4. c:\home\**\*.xml : all files having "xml" extension below 'c:\home\' and it's all sub directories.     *     * 1. *  It matches zero , one or more than one characters. While matching, it will not cross directories boundaries.     * 2. ** It does the same as * but it crosses the directory boundaries.     * 3. ?  It matches only one character for the given name.     * 4. \  It helps to avoid characters to be interpreted as special characters.     * 5. [] In a set of characters, only single character is matched. If (-) hyphen is used then, it matches a range of characters. Example: [efg] matches "e","f" or "g" . [a-d] matches a range from a to d.     * 6. {} It helps to matches the group of sub patterns.     *     * 1. *.java when given path is java , we will get true by PathMatcher.matches(path).     * 2. *.* if file contains a dot, pattern will be matched.     * 3. *.{java,txt} If file is either java or txt, path will be matched.     * 4. abc.? matches a file which start with abc and it has extension with only single character.     *     * </pre>     *     * @return list of files or directories     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static List<Path> find( String searchDir, boolean includeFile, boolean includeDirectory, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        searchDir = Strings.trim( searchDir );        if( Strings.isEmpty( searchDir ) ) return new ArrayList<>();        return find( Paths.get( searchDir ), includeFile, includeDirectory, scanDepth, matchingPattern ) ;    }    /**     * Search list of files or directories in sub directory.     *     *     * @param searchDir         root directory to search     * @param includeFile       include file     * @param includeDirectory  include directory     * @param scanDepth         depth to scan     * <pre>     *   -1 : infinite     *    0 : in searchDir itself     *    1 : from searchDir to 1 depth sub directory     *    2 : from searchDir to 2 depth sub directory     *    ...     * </pre>     * @param matchingPattern   path matching pattern (glob expression. if not exists, add all result)     * <pre>     * ** : ignore directory variation     * *  : filename LIKE search     *     * 1. **.xml           : all files having "xml" extension below searchDir and it's all sub directories.     * 2. *.xml            : all files having "xml" extension in searchDir     * 3. c:\home\*\*.xml  : all files having "xml" extension below 'c:\home\' and it's just 1 depth below directories.     * 4. c:\home\**\*.xml : all files having "xml" extension below 'c:\home\' and it's all sub directories.     *     * 1. *  It matches zero , one or more than one characters. While matching, it will not cross directories boundaries.     * 2. ** It does the same as * but it crosses the directory boundaries.     * 3. ?  It matches only one character for the given name.     * 4. \  It helps to avoid characters to be interpreted as special characters.     * 5. [] In a set of characters, only single character is matched. If (-) hyphen is used then, it matches a range of characters. Example: [efg] matches "e","f" or "g" . [a-d] matches a range from a to d.     * 6. {} It helps to matches the group of sub patterns.     *     * 1. *.java when given path is java , we will get true by PathMatcher.matches(path).     * 2. *.* if file contains a dot, pattern will be matched.     * 3. *.{java,txt} If file is either java or txt, path will be matched.     * 4. abc.? matches a file which start with abc and it has extension with only single character.     * </pre>     *     * @return list of files or directories     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static List<Path> find( Path searchDir, boolean includeFile, boolean includeDirectory, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        if( notExists( searchDir ) ) return new ArrayList<>();        Path rootDir = isFile( searchDir ) ? searchDir.getParent() : searchDir;        FileFinder finder = new FileFinder( includeFile, includeDirectory, matchingPattern );        scanDepth = ( scanDepth < 0 ) ? Integer.MAX_VALUE : ++scanDepth;        try {        	java.nio.file.Files.walkFileTree( rootDir, EnumSet.noneOf( FileVisitOption.class ), scanDepth, finder );        } catch( IOException e ) {	        throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }        return finder.getFoundPaths();    }    public static List<Path> findFile( String searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, true, false, scanDepth, matchingPattern );    }    public static List<Path> findFile( Path searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, true, false, scanDepth, matchingPattern );    }    public static List<Path> findDirectory( String searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, false, true, scanDepth, matchingPattern );    }    public static List<Path> findDirectory( Path searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, false, true, scanDepth, matchingPattern );    }    public static List<Path> findAll( String searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, true, true, scanDepth, matchingPattern );    }    public static List<Path> findAll( Path searchDir, int scanDepth, String... matchingPattern ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return find( searchDir, true, true, scanDepth, matchingPattern );    }    /**     * check path exists     *     * @param   path    file or directory path     * @param   options options indicating how symbolic links are handled     * @return true if path exists     */    public static boolean exists( Path path, LinkOption... options ) {        return path != null && java.nio.file.Files.exists( path, options );    }    /**     * check path exists     *     * @param   path    file or directory path     * @param   options options indicating how symbolic links are handled     * @return true if path exists     */    public static boolean exists( String path, LinkOption... options ) {        return exists( toPath( path ), options );    }    /**     * check file exist     * @param   file    file to check     * @param   options options indicating how symbolic links are handled     * @return true if file exists     */    public static boolean exists( File file, LinkOption... options ) {        return file != null && exists( file.toPath(), options );    }    /**     * check path exists     *     * @param   path    file or directory path     * @param   options options indicating how symbolic links are handled     * @return true if path exists     */    public static boolean notExists( Path path, LinkOption... options ) {        return ! exists( path, options );    }    /**     * check path does not exist     *     * @param path      file or directory path     * @param options   options indicating how symbolic links are handled     * @return true if path does not exist     */    public static boolean notExists( String path, LinkOption... options ) {        return ! exists( path, options );    }    /**     * check file does not exist     * @param file      file to check     * @param options   options indicating how symbolic links are handled     * @return true if file does not exist     */    public static boolean notExists( File file, LinkOption... options ) {        return ! exists( file, options );    }    private static Path toPath( String path ) {        if( path == null ) return null;        try {            return Paths.get( path.trim() );        } catch ( Exception e ) {            return null;        }    }    /**     * check path is file or not     * @param path      file path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is file.     */    public static boolean isFile( Path path, LinkOption... options ) {    	return path != null && java.nio.file.Files.isRegularFile( path, options );    }    /**     * check path is file or not     * @param path      file path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is file.     */    public static boolean isFile( String path, LinkOption... options ) {        try {            return isFile( toPath(path), options );        } catch( InvalidPathException e ) {            return false;        }    }    /**     * check path is file or not     * @param path      path path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is file.     */    public static boolean isFile( File path, LinkOption... options ) {    	return path != null && isFile( path.toPath(), options );    }    /**     * check path is directory or not     * @param path      path path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is directory.     */    public static boolean isDirectory( Path path, LinkOption... options ) {    	return path != null && java.nio.file.Files.isDirectory( path, options );    }    /**     * check path is directory or not     * @param path      path path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is directory.     */    public static boolean isDirectory( String path, LinkOption... options ) {    	try {            return isDirectory( toPath(path), options );        } catch( InvalidPathException e ) {            return false;        }    }    /**     * check path is directory or not     * @param path      path path to check     * @param options   options indicating how symbolic links are handled     * @return true if path is directory.     */    public static boolean isDirectory( File path, LinkOption... options ) {    	return path != null && isDirectory( path.toPath(), options );    }    /**     * Make directory     *     * @param directoryPath directory path     * @return created directory     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeDir( String directoryPath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	if( directoryPath == null ) return null;    	return makeDir( toPath( directoryPath ) );    }    /**     * Make directory     *     * @param directory directory path     * @return created directory     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeDir( File directory ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        if( directory == null ) return null;        return makeDir( directory.toPath() );    }    /**     * Make directory     *     * @param directory directory path     * @return created directory     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeDir( Path directory ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	if( directory == null ) return null;    	if( exists(directory) ) return directory.toFile();    	try {    		return java.nio.file.Files.createDirectories( directory ).toFile();    	} catch( IOException e ) {    		throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );    	}    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param filePath file path     * @return created file     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeFile( String filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	return makeFile( toPath(filePath) );    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param filePath file path     * @return created file     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeFile( Path filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	if( filePath == null ) return null;    	if( java.nio.file.Files.exists( filePath ) ) {    		return filePath.toFile();    	} else {    		makeDir( filePath.getParent().toString() );    	}    	try {    		return java.nio.file.Files.createFile( filePath ).toFile();    	} catch( IOException e ) {    		throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );    	}    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param file file to create     * @return created file     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static File makeFile( File file ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	if( file == null ) return null;    	return makeFile( file.toPath() );    }    /**     * Move file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O error occurs     */    public static void move( String source, String target, boolean overwrite ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        move( toPath(source), toPath(target), overwrite );    }    /**     * Move file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O error occurs     */    public static void move( Path source, Path target, boolean overwrite ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        CopyOption[] option = overwrite                ? new CopyOption[] { StandardCopyOption.REPLACE_EXISTING }                : new CopyOption[] {};        try {            if( java.nio.file.Files.isDirectory(source) ) {                java.nio.file.Files.move( source, target, option );            } else {                if( java.nio.file.Files.isDirectory(target) ) {                    java.nio.file.Files.move( source, target.resolve( source.getFileName() ), option );                } else {                    java.nio.file.Files.move( source, target, option );                }            }        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    /**     * Copy file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O error occurs     */    public static void copy( String source, String target, boolean overwrite ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        copy( toPath(source), toPath(target), overwrite );    }    /**     * Copy file or directory     *     * @param  source     file or directory path to copy     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O error occurs     */    public static void copy( Path source, Path target, boolean overwrite ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        CopyOption[] option = overwrite                ? new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING }                : new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES };        try {            if( isDirectory(source) ) {                for( Path sourcePath : find( source, true, true, -1 ) ) {                    Path targetPath = target.resolve( source.relativize(sourcePath) );                    if( isDirectory( targetPath ) ) {                        makeDir( targetPath );                        continue;                    }                    java.nio.file.Files.copy( sourcePath, targetPath, option );                }            } else {                if( java.nio.file.Files.isDirectory(target) ) {                    java.nio.file.Files.copy( source, target.resolve( source.getFileName() ), option );                } else {                    java.nio.file.Files.copy( source, target, option );                }            }        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    /**     * Read serialized objects data stored in file     *     * @param filePath  path of file which store serialized objects data.     * @param <T>       expected class of return     * @return object bean to serialize     * @throws UncheckedClassNotFoundException   if object's class is not defined     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException     if an I/O error occurs     */    public static <T> T readObject( String filePath ) throws UncheckedClassNotFoundException, io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        try(            InputStream file   = new FileInputStream( filePath );            InputStream buffer = new GZIPInputStream( file );            ObjectInput input  = new ObjectInputStream( buffer )        ) {            Object val = input.readObject();            return val == null ? null : (T) val;        } catch( ClassNotFoundException e ) {            throw new UncheckedClassNotFoundException( e );        } catch( IOException e ) {        	throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    /**     * Read serialized objects data stored in file     *     * @param file  file stored serialized objects data.     * @param <T>   expected class of return     * @return object bean to serialize     * @throws UncheckedClassNotFoundException   if object's class is not defined     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException     if an I/O error occurs     */    public static <T> T readObject( File file ) throws UncheckedClassNotFoundException, io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	return readObject( file.getPath() );    }    /**     * write bean to file     *     * @param filePath  full file path     * @param bean      bean to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  file I/O exception     */    public static void writeObject( String filePath, Object bean ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        makeFile( filePath );        try(            OutputStream file   = new FileOutputStream( filePath );            OutputStream buffer = new GZIPOutputStream( file );            ObjectOutput output = new ObjectOutputStream( buffer )        ) {            output.writeObject( bean );            output.flush();        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    /**     * write bean to file     *     * @param file  file     * @param bean  bean to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeObject( File file, Object bean ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeObject( file.getPath(), bean );    }    /**     * remove extension from path     *     * @param file  file     * @return file path which has no extension.     */    public static String removeExtension( Path path ) {        if( path == null ) return null;        return removeExtension( path.toString() );    }    /**     * remove extension from path     *     * @param file  file     * @return file path which has no extension.     */    public static String removeExtension( File file ) {        if( file == null ) return null;        return removeExtension( file.getPath() );    }    /**     * remove extension from path     *     * @param filePath  file path (or file name)     * @return file path which has no extension.     */    public static String removeExtension( String filePath ) {        if( filePath == null ) return null;        int index = filePath.lastIndexOf( '.' );        if( index < 0 ) return filePath;        String ext = filePath.substring( index + 1 );        if( ext.contains(File.pathSeparator) || ext.contains("/") ) return filePath;        return filePath.substring( 0, index );    }    /**     * Read text from file     * @param filePath  file path     * @return text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static String readFrom( String filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	return readFrom( filePath, "" );    }    /**     * Read text from file     *     * @param filePath  file path     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @return text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static String readFrom( String filePath, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	StringBuilder sb = new StringBuilder();    	readFrom( filePath, readLine -> sb.append( readLine ).append( '\n' ), charset );    	return sb.toString();    }    /**     * Read text from file     *     * @param file      file path     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @return text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static String readFrom( File file, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	return readFrom( file.getPath(), charset );    }    /**     * Read text from file     *     * @param file      file path     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @return text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static String readFrom( Path file, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return readFrom( file.toString(), charset );    }    /**     * Read text from file     *     * @param file file path     * @return text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static String readFrom( File file ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	return readFrom( file.getPath(), CHARSET_AUTODETECT );    }    /**     * Read text from file     *     * <pre>     *   StringBuilder sb = new StringBuilder();     *     *   readFrom( filePath, readLine -&gt; {     *     sb.append( readLine ).append( '\n' );     *   });     *     *   System.out.println( sb );     * </pre>     *     * @param filePath  file path     * @param reader    reader to treat line in text     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static void readFrom( Path filePath, LineReader reader ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        readFrom( filePath, reader, CHARSET_AUTODETECT );    }    /**     * Read text from file     *     * <pre>     *   StringBuilder sb = new StringBuilder();     *     *   readFrom( filePath, readLine -&gt; {     *     sb.append( readLine ).append( '\n' );     *   }, charset );     *     *   System.out.println( sb );     * </pre>     *     * @param filePath  file path     * @param reader    worker to treat line in text     * @param charset   character set (UTF-8, EUC-KR, ... )     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if I/O error occurs     */    public static void readFrom( Path filePath, LineReader reader, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        readFrom( filePath.toString(), reader, charset );    }    public static void readFrom( File filePath, LineReader reader, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	readFrom( filePath.toString(), reader, charset );    }    public static void readFrom( File filePath, LineReader reader ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	readFrom( filePath.toString(), reader, CHARSET_AUTODETECT );    }    public static void readFrom( String filePath, LineReader reader ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        readFrom( filePath, reader, CHARSET_AUTODETECT );    }    public static void readFrom( String filePath, LineReader reader, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        try {            FileInputStream fis = new FileInputStream( filePath );            readFrom( fis, reader, charset );        } catch( FileNotFoundException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    public static String readFrom( InputStream inputStream ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        StringBuilder sb = new StringBuilder();        readFrom( inputStream, readLine -> sb.append( readLine ).append( '\n' ), CHARSET_AUTODETECT );        return sb.toString();    }    public static void readFrom( InputStream inputStream, LineReader reader ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        readFrom( inputStream, reader, null );    }    public static void readFrom( InputStream inputStream, LineReader reader, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        BufferedInputStream mis = new BufferedInputStream( inputStream );        if( Strings.isEmpty(charset) ) {            charset = getCharset( mis );        }        try(            BufferedReader br = new BufferedReader( new InputStreamReader(mis, charset) )        ) {            String line;            while( ( line = br.readLine() ) != null ) {                reader.read( line );            }        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        } finally {            if( mis != null ) try { mis.close(); } catch( IOException e ) {}        }    }    public static void readResourceFrom( String filePath, LineReader reader ) {        readResourceFrom( filePath, reader, null );    }    public static void readResourceFrom( String filePath, LineReader reader, String charset ) {        if( Files.exists( filePath ) ) {            readFrom( filePath, reader, charset );        } else {            String resourcePath = toResourceName( filePath );            InputStream inputStream = Classes.getResourceAsStream( resourcePath );            if( inputStream != null ) {                readFrom( inputStream, reader, charset );            }        }    }    /**     * Convert file path to resource path. <br>     *     * (remove root path from file path.)     *     * @param filePath file path     * @return resource path     */    public static String toResourceName( String filePath ) {        return normalizeSeparator( filePath )            .replaceFirst( "^" + getRootPath(), "" )            .replaceFirst( "^/+", "" );    }    public static String readResourceFrom( String filePath ) {        return readResourceFrom( filePath, "" );    }    public static String readResourceFrom( String filePath, String charset ) {        StringBuilder sb = new StringBuilder();        readResourceFrom( filePath, readLine -> sb.append( readLine ).append( '\n' ), charset );        return sb.toString();    }    public static boolean isResourceExists( String resourcePath ) {        if( exists( resourcePath ) ) {            return true;        } else {            resourcePath = toResourceName( resourcePath );            return Classes.isResourceExisted( resourcePath );        }    }    public static InputStream getResource( String filePath ) {        if( isFile( filePath ) ) {            try {                return new FileInputStream( filePath );            } catch( FileNotFoundException e ) {                throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );            }        } else {            String resourcePath = toResourceName( filePath );            return Classes.getResourceAsStream( resourcePath );        }    }    /**     * Write text to file     *     * <pre>     *  writeTo( filePath, writer -&gt; {     *    writer.write( text );     *  }, "EUC-KR" );     * </pre>     *     * @param filePath  file path to write text     * @param writer    writer to write buffer     * @param charset   encoding character set     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O exception occurs     */    public static void writeTo( String filePath, BufferWriter writer, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        makeFile( filePath );        try(            FileOutputStream fos    = new FileOutputStream( filePath );            BufferedWriter   buffer = new BufferedWriter( new OutputStreamWriter( fos, charset ) )        ) {            writer.write( buffer );        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException(e);        }    }    /**     * Write text to file (encoding characterset is "UTF-8")     *     * <pre>     *  writeTo( filePath, writer -&gt; {     *    writer.write( text );     *  });     * </pre>     *     * @param filePath  file path to write text     * @param writer   writer to write line     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O exception occurs     */    public static void writeTo( String filePath, BufferWriter writer ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeTo( filePath, writer, UTF_8 );    }    /**     * Write text to file     *     * @param filePath  file full path     * @param text      text to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeTo( String filePath, final String text ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeTo( filePath, text, UTF_8 );    }    /**     * Write text to file     *     * @param filePath  file full path     * @param text      text to write     * @param charset   encoding character set     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeTo( String filePath, final String text, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeTo( filePath, writer -> {            writer.write( text );        }, charset );    }    /**     * Write text to file     *     * @param file  file     * @param text  text to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeTo( File file, final String text ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	writeTo( file.getAbsolutePath(), text );    }    /**     * Write binary data to file     *     * @param file  file to write     * @param binary binary data to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeTo( String file, byte[] binary ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	makeFile( file );    	FileOutputStream stream = null;    	try {    		stream = new FileOutputStream( file );    	    stream.write( binary );    	} catch( IOException e ) {	        throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException(e);        } finally {    	    if( stream != null ) try { stream.close(); } catch( IOException e ) {}    	}    }    /**     * Write binary data to file     *     * @param path   file path to write     * @param binary binary data to write     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException  if an I/O error occurs     */    public static void writeTo( Path path, byte[] binary ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeTo( path.toString(), binary );    }    /**     * Write data as CSV file     *     * @param file      file to write     * @param data      data represents excel sheet     * @param delimiter delimiter to seperate data     * @param charset   character set     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O exception occurs     */    public static void writeCsvTo( String file, List data, String delimiter, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        writeCsvTo( file, new NList( data ), delimiter, charset );    }    /**     * Write data as CSV file     *     * @param file      file to write     * @param data      data represents excel sheet     * @param delimiter delimiter to seperate data     * @param charset   character set     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException if an I/O exception occurs     */    public static void writeCsvTo( String file, NList data, String delimiter, String charset ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	writeTo( file, writer -> {            writer.write( Strings.join( data.getAliases(), delimiter ) );            writer.write( '\n' );            for( int row = 0, rowCnt = data.size(); row < rowCnt; row++ ) {                List<String> temp = new ArrayList<>();                for( int col = 0, colCnt = data.keySize(); col < colCnt; col++ ) {                    temp.add( Strings.nvl( data.get( col, row ) ) );                }                writer.write( Strings.join( temp, delimiter ) );                writer.write( '\n' );            }        }, charset );    }    /**     * Convert relative path to absolute path     *     * <pre>     * Files.toAbsolutePath( "/home/user/nayasis", "../test/abc" );     *     * → "/home/user/test/abc"     * </pre>     *     * @param basePath   bast path     * @param targetPath target path to convert     * @return absolute path     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException base path is not existed     */    public static String toAbsolutePath( String basePath, String targetPath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	Path pathBase = getDirectory( Paths.get(basePath) );    	return normalizeSeparator( pathBase.resolve( targetPath ).normalize().toString() );    }    /**     * Convert absolute path to relative path     *     * <pre>     * Files.toRelativePath( "/home/user/nayasis", "/home/user/test/abc" );     *     * → "../test/abc"     * </pre>     *     * @param basePath   base path     * @param targetPath target path to convert     * @return relative path     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException    base path is not existed     */    public static String toRelativePath( String basePath, String targetPath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {    	Path pathBase = getDirectory( Paths.get(basePath) );    	return normalizeSeparator( pathBase.relativize( Paths.get( targetPath ) ).toString() );    }    /**     * get current directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException path is not invalid     */    public static File getDirectory( String path ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return getDirectory( Paths.get(path) ).toFile();    }    /**     * get current directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException path is not invalid     */    public static File getDirectory( File path ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return getDirectory( path.toPath() ).toFile();    }    /**     * get current directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException path is not invalid     */    public static Path getDirectory( Path path ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return isDirectory(path) ? path : path.getParent();    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     * @param charset characterset (default : UTF-8)     */    public static void zip( File fileOrDirectoryToZip, File targetFile, Charset charset ) {        getZipFileHandler().zip( fileOrDirectoryToZip, targetFile, charset );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     */    public static void zip( File fileOrDirectoryToZip, File targetFile ) {        zip( fileOrDirectoryToZip, targetFile, Charset.defaultCharset() );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     * @param charset characterset (default : UTF-8)     */    public static void zip( Path fileOrDirectoryToZip, Path targetFile, Charset charset ) {        zip( fileOrDirectoryToZip.toFile(), targetFile.toFile(), charset );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     */    public static void zip( Path fileOrDirectoryToZip, Path targetFile ) {        zip( fileOrDirectoryToZip.toFile(), targetFile.toFile() );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     * @param charset characterset (default : UTF-8)     */    public static void unzip( File fileToUnzip, File targetDirectory, Charset charset ) {        getZipFileHandler().unzip( fileToUnzip, targetDirectory, charset );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     */    public static void unzip( File fileToUnzip, File targetDirectory ) {        unzip( fileToUnzip, targetDirectory, Charset.defaultCharset() );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     * @param charset characterset (default : UTF-8)     */    public static void unzip( Path fileToUnzip, Path targetDirectory, Charset charset ) {        unzip( fileToUnzip.toFile(), targetDirectory.toFile(), charset );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     */    public static void unzip( Path fileToUnzip, Path targetDirectory ) {        unzip( fileToUnzip.toFile(), targetDirectory.toFile() );    }    private static ZipFileHandler getZipFileHandler() {        try {            return new ZipFileHandler();        } catch( Throwable e ) {            String errorMessage =                "you must import [Apache Common Compress Library] to handle zip file.\n" +                        "\t- Maven dependency is like below.\n" +                        "\t\t<dependency>\n" +                        "\t\t  <groupId>org.apache.commons</groupId>\n" +                        "\t\t  <artifactId>commons-compress</artifactId>\n" +                        "\t\t  <version>1.18</version>\n" +                        "\t\t</dependency>\n";            throw new NoClassDefFoundError( errorMessage );        }    }    /**     * Resolve path with base path     *     * <pre>     *   Files.getPath( "/root/bin", ".././temp" ); -> "/root/temp"     *   Files.getPath( "/root/bin", "/./temp" );   -> "/root/bin/temp"     *   Files.getPath( "/root/bin", "temp" );      -> "/root/bin/temp     * </pre>     *     * @param basePath      base path     * @param resolvedPath  path to resolve with base path     * @return resolved path     */    public static String resolvePath( String basePath, String resolvedPath ) {        List<String> pathList = Strings.tokenize( normalizeSeparator( basePath ), "/" );        List<String> children = Strings.tokenize( normalizeSeparator( resolvedPath ), "/" );        pathList.addAll( children );        for( int i = 0, iCnt = pathList.size(); i < iCnt; i++ ) {            String path = pathList.get( i );            if( "".equals(path) || ".".equals(path) ) {                pathList.remove( i );                iCnt--;            } else if( "..".equals( path ) ) {                pathList.remove( i );                iCnt--;                if( i > 0 && pathList.size() > 1 ) {                    pathList.remove( i - 1 );                    iCnt--;                }            }        }        return Strings.join( pathList, "/" );    }    /**     * read file attributes     *     * @param filePath  file path     * @return basic attributes     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException occurs when raise file I/O errir     */    public static BasicFileAttributes readAttribute( Path filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        try {            return java.nio.file.Files.readAttributes( filePath, BasicFileAttributes.class );        } catch( IOException e ) {            throw new io.nayasis.common.basica.exception.unchecked.UncheckedIOException( e );        }    }    /**     * read file attributes     *     * @param filePath  file path     * @return basic attributes     * @throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException occurs when raise file I/O errir     */    public static BasicFileAttributes readAttribute( String filePath ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        return readAttribute( Paths.get( filePath ) );    }    /**     * get user home directory path     *     * @return user home path     */    public static String getUserHome() {        String userHome = System.getProperty( "user.home" );        return normalizeSeparator( userHome );    }    /**     * get root directory where program is running     *     * @return root directory     */    public static String getRootPath() {        try {            if( Classes.isRunningInJar() ) {                return Files.normalizeSeparator( new File( "." ).getAbsolutePath() ).replaceFirst( "/\\.$", "" );            } else {                URL root = Classes.getClassLoader().getResource( "" );                return Files.normalizeSeparator( Paths.get(root.toURI()).toString() );            }        } catch( URISyntaxException e ) {            throw new BaseRuntimeException( e );        }    }    /**     * get current directory where program is running     *     * @return current directory     */    public static String getCurrentPath() {        String currentPath = Paths.get("").toAbsolutePath().toString();        return normalizeSeparator( currentPath );    }    /**     * detect file's character set     *     * @param filePath  file path     * @return  detected character set (UTF-8, EUC-KR, EUC-JP, ... )     */    public static String getCharset( String filePath ) throws UncheckedFileNotFoundException, io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        FileInputStream inputStream;        try {            inputStream = new FileInputStream( filePath );        } catch ( FileNotFoundException e ) {            throw new UncheckedFileNotFoundException( e );        }        try {            return getCharset( new BufferedInputStream(inputStream) );        } catch ( io.nayasis.common.basica.exception.unchecked.UncheckedIOException e ) {            throw e;        } finally {            if( inputStream != null ) try { inputStream.close(); } catch( IOException e ) {}        }    }    /**     * detect file's character set     *     * @param inputStream  input stream     * @return  detected character set (UTF-8, EUC-KR, EUC-JP, ... )     */    public static String getCharset( BufferedInputStream inputStream ) throws io.nayasis.common.basica.exception.unchecked.UncheckedIOException {        byte[] buf = new byte[4096];        UniversalDetector detector = null;        try {            inputStream.mark( 1 << 24 );            detector = new UniversalDetector( null );            int nread;            while ( (nread = inputStream.read(buf)) > 0 && ! detector.isDone() ) {                detector.handleData( buf, 0, nread );            }            detector.dataEnd();            String charset = detector.getDetectedCharset();            return charset == null ? "UTF-8" : charset;        } catch( IOException e ) {            throw new UncheckedIOException( e );        } finally {            if( detector    != null ) try { detector.reset(); } catch( Exception e ) {}            if( inputStream != null ) try {                inputStream.reset();            } catch( IOException e ) {}        }    }}